<?xml version="1.0" encoding="UTF-8"?>
<chapter id="tutorial">
	<title>MobilityDB Tutorial</title>
	<para>To illustrate the capabilities of MobilityDB, we give an example use case that loads, explores, and query mobility data. The data used is based on the <ulink url="http://dna.fernuni-hagen.de/secondo/BerlinMOD/BerlinMOD.html">BerlinMOD</ulink> benchmark for moving object databases and is available as a <ulink url="https://docs.mobilitydb.com/data/berlinmod_data.zip">ZIP</ulink> file.</para>

	<sect1>
		<title>Installation</title>

		<para>For this tutorial we will use a Docker image containing MobilityDB and all its dependencies (including PostgreSQL and PostGIS). The container has a default database called <varname>mobilitydb</varname> with the MobilityDB extension installed where <varname>user = pw = docker</varname>. This presupposes that you have installed Docker into your computer. In that case, you can run the following command.
			<programlisting language="bash" xml:space="preserve">
docker pull codewit/mobilitydb
docker volume create mobilitydb_data
docker run --name "mobilitydb" -d -p 25432:5432 -v mobilitydb_data:/var/lib/postgresql 
codewit/mobilitydb
</programlisting>
			In the above commands
			<itemizedlist>
				<listitem><para><varname>docker pull</varname> downloads the Docker image of <varname>mobilitydb</varname>. If the image has been downloaded before, this checks whether a more recent image has been published in the docker repository, and downloads it. It is better to call this command every time, to ensures that you have the latest most up-to-date version of this image.</para></listitem>

				<listitem><para><varname>docker volume create mobilitydb_data</varname> creates a volume container on the host, that we will use to persist the PostgreSQL database files outside of the MobilityDB container. You need to run this command only once, during the first use of the image</para>
				</listitem>

				<listitem><para><varname>docker run --name=mobilitydb</varname> tells Docker our new container will be named <varname>mobilitydb</varname>.</para></listitem>

				<listitem><para><varname>-d</varname> runs the container in the background (detached mode).</para></listitem>

				<listitem><para><varname>-p 25432:5432</varname> maps TCP port 5432 in the container to port 25432 on the Docker host (to prevent potential conflicts with any local database instance you may have). This is required because the PostgreSQL database server in the container listens for connections on port 5432 by default.</para>
				</listitem>

				<listitem><para><varname>-v mobilitydb_data:/var/lib/postgresql</varname> tells the container filesystem to mount the <varname>mobilitydb_data</varname> volume that we have just created to the path /var/lib/postgresql. This means that any database objects that the container saves or creates (by default in <varname>/var/lib/postgresql</varname>) will instead be persisted in the <varname>mobilitydb_data</varname> directory, which is stored in the host. This options ensures that your data will not be lost when the container is removed. </para>
				</listitem>

				<listitem><para><varname>codewit/mobilitydb</varname> tells Docker to pull the docker image with that name from Docker Hub.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>
		Now we can launch any PostgreSQL administrative front-end to start using MobilityDB. Two traditional ones are the command-line tool <varname>psql</varname> and the graphical tool <varname>pgAdmin</varname>. We can launch <varname>psql</varname> as follows.
			<programlisting language="bash" xml:space="preserve">
docker exec -t -i mobilitydb psql -h localhost -p 5432 -d mobilitydb -U docker
</programlisting>
			In the above command
			<itemizedlist>
				<listitem><para><varname>docker exec -t -i mobilitydb psql</varname> tells Docker to allocate a pseudo-TTY, to keep STDIN open, and to execute in the container <varname>mobilitydb</varname> the command <varname>psql</varname>.</para></listitem>

				<listitem><para><varname>-h localhost -p 5432 -d mobilitydb -U docker</varname> tells <varname>psql</varname>, respectively, the database server host, the server port, the database name, and the user name.</para></listitem>
			</itemizedlist>
			Note that you will be prompted to provide the password, which is also <varname>docker</varname>.
		</para>

		<para>
		In order to launch <varname>pgAdmin</varname>, there are two options to create a connection. The first option is to set the host to the localhost (127.0.0.1), and the port to the mapped one on the host, as per the <varname>docker run</varname> command. In this example the port is 25432. Now we can launch <varname>pgAdmin</varname> and establish a new connection to the docker container. This is done as shown in <xref linkend="pgAdmin" />. 
		</para>

		<figure id="pgAdmin" float="start"><title>Configuration of a connection to the docker image in pgAdmin.</title>
			<mediaobject>
				<imageobject><imagedata scale='50' fileref='images/pgAdmin.png' /></imageobject>
			</mediaobject>
		</figure>

		<para>
		The second option is to know the IP address used by docker container with the following command.
			<programlisting language="bash" xml:space="preserve">
docker-machine ip
-- 192.168.99.101
</programlisting>
			Notice that the address obtained in your computer may be different from the one above. Now we can launch <varname>pgAdmin</varname> and establish a new connection to the docker container. This is done as shown in <xref linkend="pgAdmin" />. The second option is to set the host to the localhost (127.0.0.1), and the port to the mapped one on the host, as per the <varname>docker run</varname> command. In this example the port would be 25432.
		</para>

		<para>
		Now you can use pgAdmin to query the mobilitydb database, as will be further explained in the following sections. Here are few more docker commands that you will eventually need:
		<programlisting language="bash" xml:space="preserve">
docker stop "mobilitydb"
docker start "mobilitydb"
docker rm "mobilitydb"
</programlisting>
			The above commands
			<itemizedlist>
				<listitem>
					<para><varname>docker stop</varname> shuts down the docker container. You need to issue this command, for example, if you need to re-start the host.</para>
				</listitem>
				<listitem>
					<para><varname>docker start</varname> launches back the docker container. You need to issue this command, for example, after re-starting the host.</para>
				</listitem>

				<listitem>
					<para><varname>docker rm</varname> removes/deletes docker container. You need to issue this command, for example, if you need to <varname>docker pull</varname> a more recent MobilityDB image. If the databases are stored in a <varname>docker volume</varname> as explained above, it will still be available after downloading and running the new image.</para>
				</listitem>
			</itemizedlist>
		</para>
	</sect1>

	<sect1>
		<title>Loading the Data</title>

		<para>The ZIP file with the data for this tutorial contains a set of CSV files as follows:
			<itemizedlist>
				<listitem>
					<para><varname>vehicles.csv</varname> with fields <varname>VehId</varname>, <varname>Licence</varname>, <varname>Type</varname>, and <varname>Model</varname> contains the vehicle descriptions (without position history).</para>
				</listitem>

				<listitem>
					<para><varname>trips.csv</varname> with fields <varname>TripId</varname>, <varname>VehId</varname>, <varname>PosX</varname>, <varname>PosY</varname>, and <varname>Instant</varname> contains vehicles movements and pauses.</para>
				</listitem>

				<listitem>
					<para><varname>instants.csv</varname> with fields <varname>InstantId</varname> and <varname>Instant</varname> contains timestamps used for queries.</para>
				</listitem>

				<listitem>
					<para><varname>periods.csv</varname> with fields <varname>PeriodId</varname>, <varname>Begin</varname>, and <varname>End</varname> contains periods used for the queries.</para>
				</listitem>

				<listitem>
					<para><varname>points.csv</varname> with fields <varname>PointId</varname>, <varname>PosX</varname>, and <varname>PosY</varname> contains points used for queries.</para>
				</listitem>

				<listitem>
					<para><varname>regions.csv</varname> with fields <varname>RegionId</varname>, <varname>SegNo</varname>, <varname>Xstart</varname>, <varname>Ystart</varname>, <varname>Xend</varname>, and <varname>Yend</varname> contains the polygons used for queries.</para>
				</listitem>

			</itemizedlist>
		</para>

		<para>
		We decompress the file with the data into a directory. This can be done using the command. 
			<programlisting language="bash" xml:space="preserve">
unzip berlinmod_data.zip
</programlisting>
		We suppose in the following that the directory used is as follows <varname>/home/mobilitydb/data/</varname>.
		</para>

		<para>
		In the following, we can use the <varname>mobilitydb</varname> database provided in the container. This database has already installed the MobilityDB extension. Alternatively, you may use another database. In that case, you can install the MobilityDB extension in your database by using the following command.
			<programlisting language="sql" xml:space="preserve">
CREATE EXTENSION MobilityDB CASCADE;
</programlisting>
		By using <varname>CASCADE</varname> we load the required PostGIS extension prior to loading MobilityDB.
		</para>

		<para>We create the tables to be loaded with the data in the CSV files as follows.
			<programlisting language="sql" xml:space="preserve">
CREATE TABLE Vehicles (
  VehId integer PRIMARY KEY,
  Licence varchar(32),
  Type varchar(32),
  Model varchar(32)
  );
CREATE TABLE TripsInput (
  TripId integer,
  VehId integer REFERENCES Vehicles,
  PosX float,
  PosY float,
  T timestamptz,
  PRIMARY KEY (TripId, T)
  );
CREATE TABLE Instants (
  InstantId integer PRIMARY KEY,
  Instant timestamptz
  );
CREATE TABLE Periods (
  PeriodId integer PRIMARY KEY,
  Tstart TimestampTz,
  Tend TimestampTz,
  Period period
  );
CREATE TABLE Points (
  PointId integer PRIMARY KEY,
  PosX double precision,
  PosY double precision,
  Geom Geometry(Point)
  );
CREATE TABLE RegionsInput (
  RegionId integer,
  PointId integer,
  XPos double precision,
  YPos double precision,
  XEnd double precision,
  YEnd double precision,
  PRIMARY KEY (RegionId, PointId)
  );
CREATE TABLE Regions (
  RegionId integer PRIMARY KEY,
  Geom Geometry(Polygon)
  );
CREATE TABLE Trips (
  TripId integer PRIMARY KEY,
  VehId integer NOT NULL,
  Trip tgeompoint NOT NULL,
  FOREIGN KEY (VehId) REFERENCES Vehicles(VehId)
  );
</programlisting>
		We created one table for each CSV file renaming attributes for better readability. In addition, we created a table <varname>Regions</varname> in order to assemble all segments composing a region into a single geometry and a table <varname>Trips</varname> in order to assemble all points composing a trip into a single temporal point.
		</para>

		<para>
		We can load the CSV files into the corresponding tables as follows.
			<programlisting language="sql" xml:space="preserve">
COPY Vehicles(VehId, Licence, Type, Model) FROM '/home/mobilitydb/data/vehicles.csv' 
  DELIMITER ',' CSV HEADER;
COPY TripsInput(TripId, VehId, PosX, PosY, T) FROM '/home/mobilitydb/data/trips.csv' 
  DELIMITER ',' CSV HEADER;
COPY Instants(InstantId, Instant) FROM '/home/mobilitydb/data/instants.csv' 
  DELIMITER ',' CSV HEADER;
COPY Periods(PeriodId, Tstart, Tend) FROM '/home/mobilitydb/data/periods.csv' 
  DELIMITER ',' CSV HEADER;
UPDATE Periods
SET Period = period(Tstart, Tend);
COPY Points(PointId, PosX, PosY) FROM '/home/mobilitydb/data/points.csv' 
  DELIMITER ',' CSV HEADER;
UPDATE Points
SET Geom = ST_Transform(ST_SetSRID(ST_MakePoint(PosX, PosY), 4326), 5676);
COPY RegionsInput(RegionId, PointId, XPos, YPos) FROM 
  '/home/mobilitydb/data/regions.csv' DELIMITER  ',' CSV HEADER;
</programlisting>
		</para>

		<para>The following query is used to load table <varname>Regions</varname> from the data in table <varname>RegionsInput</varname>.
			<programlisting language="sql" xml:space="preserve">
INSERT INTO Regions(RegionId, Geom)
SELECT RegionId, ST_MakePolygon(ST_MakeLine(array_agg(
ST_Transform(ST_SetSRID(ST_MakePoint(XPos, YPos), 4326), 5676) ORDER BY PointId)))
FROM RegionsInput
GROUP BY RegionId;
</programlisting>
		</para>

		<para>The following query is used to load table <varname>Trips</varname> from the data in table <varname>TripsInput</varname>.
			<programlisting language="sql" xml:space="preserve">
INSERT INTO Trips(TripId, VehId, Trip)
SELECT TripId, VehId, tgeompoint_seq(array_agg(tgeompoint_inst(
  ST_Transform(ST_SetSRID(ST_MakePoint(PosX, PosY), 4326), 5676), T) ORDER BY T))
FROM TripsInput
GROUP BY VehId, TripId;
</programlisting>
		There are a lot of nested functions, so reading from the innermost:
			<itemizedlist>
				<listitem>
					<para>Function <varname>ST_MakePoint</varname> construct a point from the <varname>PosX</varname> and <varname>PosY</varname> values.</para>
				</listitem>

				<listitem>
					<para>Function <varname>ST_SetSRID</varname> sets the SRID of the point to 4326, that is, to the standard WGS 84 GPS coordinates.</para>
				</listitem>

				<listitem>
					<para>Function <varname>ST_Transform</varname> transforms the spherical GPS coordinates to plannar coordinates fitted for Germany.</para>
				</listitem>

				<listitem>
					<para>Function <varname>tgeompointinst</varname> gets the point and the time values to create a temporal point of instant duration.</para>
				</listitem>

				<listitem>
					<para>Function <varname>array_agg</varname> collects in an array all temporal points of a given car and a given trip (as specified by the <varname>GROUP BY</varname> clause) and sort them by time (as specified by the <varname>ORDER BY</varname> clause)</para>
				</listitem>

				<listitem>
					<para>Function <varname>tgeompoint_seq</varname> gets the array of temporal points and construct a temporal point of sequence duration.</para>
				</listitem>

			</itemizedlist>
		</para>

		<para>Finally, we create indexes on traditional, spatial, temporal or spatiotemporal attributes as well as views to select a subset of the rows from the corresponding tables. This can be done as follows.
			<programlisting language="sql" xml:space="preserve">
CREATE INDEX Instants_Instant_Idx ON Instants USING btree(Instant);
CREATE INDEX Periods_Period_Idx ON Periods USING gist(Period);
CREATE INDEX Points_Geom_Idx ON Points USING gist(Geom);
CREATE INDEX Regions_Geom_Idx ON Regions USING gist(Geom);
CREATE INDEX Trips_VehId_Idx ON Trips USING btree(VehId);
CREATE INDEX Trips_Trip_gist_Idx ON Trips USING gist(trip);

CREATE VIEW Instants1 AS SELECT * FROM Instants LIMIT 10;
CREATE VIEW Periods1 AS SELECT * FROM Periods LIMIT 10;
CREATE VIEW Points1 AS SELECT * FROM Points LIMIT 10;
CREATE VIEW Regions1 AS SELECT * FROM Regions LIMIT 10;
CREATE VIEW Vehicles1 AS SELECT * FROM Vehicles LIMIT 10;
CREATE VIEW Trips1 AS SELECT * FROM Trips LIMIT 100;
</programlisting>
		</para>
	</sect1>

	<sect1>
		<title>Loading the Data in Partitioned Tables</title>
		<para>
		PostgreSQL provides partitioning mechanisms so that large tables can be split in smaller physical tables. This may result in increased performance when querying and manipulating large tables. We will split the <varname>Trips</varname> table given in the previous section using list partitioning, where each partitition will contain all the trips that start at a particular date. For doing this, we use the procedure given next for automatically creating the partitions according to a date range.
		</para>
		<programlisting language="sql" xml:space="preserve">
CREATE OR REPLACE FUNCTION create_partitions_by_date(TableName TEXT, StartDate DATE,
  EndDate DATE)
RETURNS void AS $$
DECLARE
  d DATE;
  PartitionName TEXT;
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.tables 
    WHERE table_name = lower(TableName)) 
  THEN
    RAISE EXCEPTION 'Table % does not exist', TableName;
  END IF;
  IF StartDate &gt;= EndDate THEN
    RAISE EXCEPTION 'The start date % must be before the end date %', StartDate, EndDate;
  END IF;
  d = StartDate;
  WHILE d &lt;= EndDate 
  LOOP
    PartitionName = TableName || '_' || to_char(d, 'YYYY_MM_DD');
    IF NOT EXISTS (
      SELECT 1
       FROM information_schema.tables 
       WHERE  table_name = lower(PartitionName))
    THEN
      EXECUTE format('CREATE TABLE %s PARTITION OF %s FOR VALUES IN (''%s'');', 
        PartitionName, TableName, to_char(d, 'YYYY-MM-DD'));
      RAISE NOTICE 'Partition % has been created', PartitionName;
    END IF;
    d = d + '1 day'::interval;
  END LOOP;
  RETURN;
END
$$ LANGUAGE plpgsql;
</programlisting>

		<para>In order to partition table <varname>Trips</varname> by date we need to add an addition column <varname>TripDate</varname> to table <varname>TripsInput</varname>.
			<programlisting language="sql" xml:space="preserve">
ALTER TABLE TripsInput ADD COLUMN TripDate DATE;
UPDATE TripsInput T1 
SET TripDate = T2.TripDate
FROM (SELECT DISTINCT TripId, date_trunc('day', MIN(T) OVER (PARTITION BY TripId))
AS TripDate FROM TripsInput) T2
WHERE T1.TripId = T2.TripId;
</programlisting>
		Notice that the <varname>UPDATE</varname> statement above takes into account the fact that a trip may finish at a day later than the starting day.
		</para>

		<para>
		The following statements create table <varname>Trips</varname> partitioned by date and the associated partitions.
			<programlisting language="sql" xml:space="preserve">
CREATE TABLE Trips (
  VehId integer NOT NULL,
  TripId integer NOT NULL,
  TripDate date,
  Trip tgeompoint,
  Traj geometry,
  PRIMARY KEY (VehId, TripId, TripDate),
  FOREIGN KEY (VehId) REFERENCES Vehicles(VehId) 
) PARTITION BY LIST(TripDate);

SELECT create_partitions_by_date('Trips', (SELECT MIN(TripDate) FROM TripsInput), 
(SELECT MAX(TripDate) FROM TripsInput));
</programlisting>
		</para>

		<para>
		To see the partitions that have been created automatically we can use the following statement.
			<programlisting language="sql" xml:space="preserve">
SELECT I.inhrelid::regclass AS child
FROM pg_inherits I
WHERE i.inhparent = 'trips'::regclass;
</programlisting>
		In our case this would result in the following output.
			<programlisting language="sql" xml:space="preserve">
"trips_2007_05_27"
"trips_2007_05_28"
"trips_2007_05_29"
"trips_2007_05_30"
</programlisting>
		</para>

		<para>We modify the query that loads table <varname>Trips</varname> from the data in table <varname>TripsInput</varname> as follows.
			<programlisting language="sql" xml:space="preserve">
INSERT INTO Trips
SELECT VehId, TripId, TripDate, tgeompoint_seq(array_agg(tgeompoint_inst(
  ST_Transform(ST_SetSRID(ST_MakePoint(PosX,PosY), 4326), 5676), T) ORDER BY T))
FROM TripsInput
GROUP BY VehId, TripId, TripDate;
</programlisting>
		Then, we can define the indexes and the views on the table <varname>Trips</varname> as shown in the previous section.
		</para>

		<para>
		An important advantange of the partitioning mechanism in PostgreSQL is that the constraints and the indexes defined on the <varname>Trips</varname> table are propagated to the partitions as shown next.
		</para>
		<programlisting language="sql" xml:space="preserve">
INSERT INTO Trips VALUES (1, 10, '2007-05-30', NULL);

ERROR:  duplicate key value violates unique constraint "trips_2007_05_30_pkey"
DETAIL:  Key (carid, TripId, tripdate)=(1, 10, 2007-05-30) already exists.

EXPLAIN SELECT COUNT(*) from Trips where Trip &amp;&amp; period '[2007-05-28, 2007-05-29]';

"Aggregate  (cost=59.95..59.96 rows=1 width=8)"
"  ->  Append  (cost=0.14..59.93 rows=8 width=0)"
"        ->  Index Scan using trips_2007_05_27_trip_idx on trips_2007_05_27  (cost=0.14..8.16 rows=1 width=0)"
"              Index Cond: (trip &amp;&amp; 'STBOX T((,,2007-05-28 00:00:00+00),(,,2007-05-29 00:00:00+00))'::stbox)"
"        ->  Index Scan using trips_2007_05_28_trip_idx on trips_2007_05_28  (cost=0.27..8.29 rows=1 width=0)"
"              Index Cond: (trip &amp;&amp; 'STBOX T((,,2007-05-28 00:00:00+00),(,,2007-05-29 00:00:00+00))'::stbox)"
"        ->  Index Scan using trips_2007_05_29_trip_idx on trips_2007_05_29  (cost=0.27..8.29 rows=1 width=0)"
"              Index Cond: (trip &amp;&amp; 'STBOX T((,,2007-05-28 00:00:00+00),(,,2007-05-29 00:00:00+00))'::stbox)"
[...]
</programlisting>

	</sect1>

	<sect1>
		<title>Exploring the Data</title>
		<para>In order to visualize the data with traditional tools such as <ulink url="https://qgis.org/">QGIS</ulink> we add to table <varname>Trip</varname> a column <varname>Traj</varname> of type <varname>geometry</varname> containing the trajectory of the trips.
			<programlisting language="sql" xml:space="preserve">
ALTER TABLE Trips ADD COLUMN traj geometry;
UPDATE Trips
SET Traj = trajectory(Trip);
</programlisting>
		The visualization of the trajectories in QGIS is given in <xref linkend="berlinmod_trips" />. In the figure red lines correspond to the trajectories of moving cars, while yellow points correspond to the position of stationary cars. In order to know the total number of trips as well as the number of moving and stationary trips we can issue the following queries.
			<programlisting language="sql" xml:space="preserve">
SELECT count(*) FROM Trips;
-- 1797
SELECT count(*) FROM Trips WHERE GeometryType(Traj) = 'POINT';
-- 969
SELECT count(*) FROM Trips WHERE GeometryType(Traj) = 'LINESTRING';
-- 828
</programlisting>
		We can also determine the spatiotemporal extent of the data using the following query.
			<programlisting language="sql" xml:space="preserve">
SELECT extent(Trip) from Trips
-- "STBOX T((2983189.5, 5831006.5,2007-05-27 00:00:00+02),
(3021179.8, 5860883,2007-05-31 00:00:00+02))"
</programlisting>
		</para>

		<figure id="berlinmod_trips" float="start"><title>Visualization of the trajectories of the trips in QGIS.</title>
			<mediaobject>
				<imageobject><imagedata scalefit="1" fileref='images/berlinmod_trips.png' /></imageobject>
			</mediaobject>
		</figure>

		<para>
		We continue investigating the data set by computing the maximum number of concurrent trips over the whole period
			<programlisting language="sql" xml:space="preserve">
SELECT maxValue(tcount(Trip)) FROM Trips;
-- 141
</programlisting>
		the average sampling rate
			<programlisting language="sql" xml:space="preserve">
SELECT AVG(timespan(Trip)/numInstants(Trip)) FROM Trips;
-- "03:43:01.695539"
</programlisting>
			and the total travelled distance in kilometers of all trips:
			<programlisting language="sql" xml:space="preserve">
SELECT SUM(length(Trip)) / 1e3 as TotalLengthKm FROM Trips;
-- 10074.8123345527
</programlisting>
		</para>

		<para>
		Now we want to know the average duration of a trip.
			<programlisting language="sql" xml:space="preserve">
SELECT AVG(timespan(Trip)) FROM Trips;
--"07:31:57.195325"
</programlisting>
		This average duration is too long. To investigate more we use the following query
			<programlisting language="sql" xml:space="preserve">
SELECT length(Trip) / 1e3, timespan(Trip) FROM Trips ORDER BY duration;
</programlisting>
		The query shows very many trips with zero length and a duration of more than one day. That would imply that there are stationary trips, representing parking overnight and even over the weekend. The previous query can hence be refined as follows:
			<programlisting language="sql" xml:space="preserve">
SELECT AVG(timespan(Trip)/numInstants(Trip)) FROM Trips WHERE length(Trip) > 0;
-- "00:00:01.861784"
</programlisting>
		</para>

		<para>
		The following query produces a histogram of trip length.
			<programlisting language="sql" xml:space="preserve">
WITH buckets (bucketNo, bucketRange) AS (
  SELECT 1, floatrange '[0, 0]' UNION
  SELECT 2, floatrange '(0, 100)' UNION
  SELECT 3, floatrange '[100, 1000)' UNION
  SELECT 4, floatrange '[1000, 5000)' UNION
  SELECT 5, floatrange '[5000, 10000)' UNION
  SELECT 6, floatrange '[10000, 50000)' UNION
  SELECT 7, floatrange '[50000, 100000)' ),
histogram AS (
  SELECT bucketNo, bucketRange, count(TripId) as freq
  FROM buckets left outer join trips on length(trip) &lt;@ bucketRange
  GROUP BY bucketNo, bucketRange
  ORDER BY bucketNo, bucketRange )
SELECT bucketNo, bucketRange, freq,
  repeat('&#9632;', ( freq::float / max(freq) OVER () * 30 )::int ) AS bar
FROM histogram;
</programlisting>
			The result of the above query is given in <xref linkend="histogram_length" />. 
		</para>

		<figure id="histogram_length" float="start"><title>Result of the query building an histogram of trip lengths.</title>
			<mediaobject>
				<imageobject><imagedata scale='80' fileref='images/histogram_length.png' /></imageobject>
			</mediaobject>
		</figure>

	</sect1>

	<sect1>
		<title>Querying the Data</title>
		<para>We discuss next four categories of queries: range queries, distance queries, temporal aggregate queries, and nearest-neighbor queries.</para>

		<sect2>
			<title>Range Queries</title>
			<para>The queries in this category restrict Trips with respect to a spatial, temporal, or spatio-temporal point or range. In the examples, the spatial points and ranges are given, respectively, in tables <varname>Points</varname> and <varname>Regions</varname>, while temporal points and ranges are given, respectively, in tables <varname>Instants</varname> and <varname>Periods</varname>.</para>

			<orderedlist>
				<listitem id="qa_range_spatial">
					<para>List the cars that have passed at a region from <varname>Regions</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT DISTINCT R.RegionId, T.VehId
FROM Trips T, Regions R
WHERE ST_Intersects(trajectory(T.Trip), R.Geom)
ORDER BY R.RegionId, T.VehId;
</programlisting>
					<para>This is a spatial range query. The query verifies that the trajectory of the car intersects the region. PostGIS performs an implicit bounding box comparison <varname>trajectory(T.Trip) &amp;&amp; R.Geom</varname> using the spatial index on table <varname>Regions</varname> when executing the predicate <varname>ST_Intersects</varname>.</para>
				</listitem>

				<listitem id="qa_range_spatiotemporal">
					<para>List the cars that were within a region from <varname>Regions</varname> during a period from <varname>Periods</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT R.RegionId, P.PeriodId, T.VehId
FROM Trips T, Regions R, Periods P
WHERE T.Trip &amp;&amp; stbox(R.Geom, P.Period) AND 
  intersects(atPeriod(T.Trip, P.Period), R.Geom)
ORDER BY R.RegionId, P.PeriodId, T.VehId;
</programlisting>
					<para>This is a spatio-temporal range query. The query performs a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on table <varname>Trips</varname>. After that, the query verifies that the location of the car during the period intersects the region. Notice that the predicate <varname>_intersects</varname> is used instead of <varname>intersects</varname> to avoid an implicit index test with the bounding box comparison <varname>atPeriod(Trip, P.Period) &amp;&amp; R.Geom</varname> is performed using the spatio-temporal index.</para>
				</listitem>

				<listitem id="qa_range_spatiotemporal_join">
					<para>List the pairs of cars that were both located within a region from <varname>Regions</varname> during a period from <varname>Periods</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT DISTINCT T1.VehId AS VehId1, T2.VehId AS VehId2, R.RegionId, P.PeriodId
FROM Trips T1, Trips T2, Regions R, Periods P
WHERE T1.VehId &lt; T2.VehId AND T1.Trip &amp;&amp; stbox(R.Geom, P.Period) AND
  T2.Trip &amp;&amp; stbox(R.Geom, P.Period) AND 
  intersects(atPeriod(T1.Trip, P.Period), R.Geom) AND
  intersects(atPeriod(T2.Trip, P.Period), R.Geom)
ORDER BY T1.VehId, T2.VehId, R.RegionId, P.PeriodId;
</programlisting>
					<para>This is a spatio-temporal range join query. The query selects two trips of different cars and performs bounding box comparisons of each trip with a region and a period using the spatio-temporal index of the <varname>Trips</varname> table. The query then verifies that both cars were located within the region during the period.</para>
				</listitem>

				<listitem id="qa_range_entering">
					<para>List the first time at which a car visited a point in <varname>Points</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T.VehId, P.PointId, MIN(startTimestamp(atValue(T.Trip,P.Geom))) AS Instant
FROM Trips T, Points P
WHERE ST_Contains(trajectory(T.Trip), P.Geom)
GROUP BY T.VehId, P.PointId;
</programlisting>
					<para>The query selects a trip and a point and verifies that the car passed by the point by testing that the trajectory of the trip contains the point. Notice that PostGIS will perform the bounding box containment <varname>trajectory(T.Trip) ~ P.Geom</varname> using the spatial index on table <varname>Points</varname> before executing <varname>ST_Contains</varname>. Then, the query projects the trip to the point with the <varname>atValue</varname> function, get the first timestamp of the projected trip with the <varname>startTimestamp</varname> function, and applies the traditional <varname>MIN</varname> aggregate function for all trips of the car and the point.</para>
				</listitem>
			</orderedlist>
		</sect2>

		<sect2>
			<title>Temporal Aggregate Queries</title>
			<para>There are three common types of temporal aggregate queries.
				<itemizedlist>
					<listitem>
						<para>Instant temporal aggregate queries in which, from a conceptual perspective, the traditional aggregate function is applied at each instant.</para>
					</listitem>

					<listitem>
						<para>Window temporal aggregate queries (also known as cumulative queries), which, given a time interval w, compute the value of the aggregate at a time instant t from the values during the time period [t-w, t].</para>
					</listitem>

					<listitem>
						<para>Span temporal aggregate queries, which, first, split the time line into predefined intervals independently of the target data, and then, for each of these intervals, aggregate the data that overlap the interval.</para>
					</listitem>
				</itemizedlist>
			</para>

			<orderedlist continuation="continues">
				<listitem id="qa_aggregate_instant">
					<para>Compute how many cars were active at each period in <varname>Periods</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT P.PeriodID, COUNT(*), TCOUNT(atPeriod(T.Trip, P.Period))
FROM Trips T, Periods P
WHERE T.Trip &amp;&amp; P.Period
GROUP BY P.PeriodID
ORDER BY P.PeriodID;
</programlisting>
					<para>This an instant temporal aggregate query. For each period, the query projects the trips to the given period and applies the temporal count to the projected trips. The condition in the <varname>WHERE</varname> clause is used for filtering the trips with the spatio-temporal index on table <varname>Trips</varname>.</para>
				</listitem>

				<listitem id="qa_aggregate_window">
					<para>For each region in <varname>Regions</varname>, give the window temporal count of trips with a 10-minute interval.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT R.RegionID, WCOUNT(atGeometry(T.Trip, R.Geom), interval '10 min')
FROM Trips T, Regions R
WHERE T.Trip &amp;&amp; R.Geom
GROUP BY R.RegionID
HAVING WCOUNT(atGeometry(T.Trip, R.Geom), interval '10 min') IS NOT NULL
ORDER BY R.RegionID;
</programlisting>
					<para>This is a window temporal aggregate query. Suppose that we are computing pollution levels by region. Since the effect of a car passing at a location lasts some time interval, this is a typical case for window aggregates. For each region, the query computes the spatial projection of the trips to the given region and apply the window temporal count to the projected trips. The condition in the <varname>WHERE</varname> clause is used for filtering the trips with the spatio-temporal index. The condition in the <varname>HAVING</varname> clause is used for removing regions that do not intersect with any trip.</para>
				</listitem>

				<listitem id="qa_aggregate_span">
					<para>Count the number of trips that were active during each hour in May 29, 2007.</para>
					<programlisting language="sql" xml:space="preserve">
WITH TimeSplit(Period) AS (
  SELECT period(H, H + interval '1 hour')
  FROM generate_series(timestamptz '2007-05-29 00:00:00', 
    timestamptz '2007-05-29 23:00:00', interval '1 hour') AS H )
SELECT Period, COUNT(*)
FROM TimeSplit S, Trips T
WHERE S.Period &amp;&amp; T.Trip AND atPeriod(Trip, Period) IS NOT NULL
GROUP BY S.Period
ORDER BY S.Period;
</programlisting>
					<para>This is a span temporal aggregate query. The query defines the intervals to consider in the <varname>TimeSplit</varname> temporary table. For each of these intervals, the main query applies the traditional count function for counting the trips that overlap the interval.</para>
				</listitem>
			</orderedlist>
		</sect2>

		<sect2>
			<title>Distance queries</title>
			<para>The queries in this category deal with either the distance travelled by a single object or the distance between two objects. The complexity of the latter queries depend, on the one hand, on whether the reference objects are static or moving, and on the other, on whether the operation required is either the minimum distance ever or the temporal distance computed at each instant.</para>

			<orderedlist continuation="continues">
				<listitem id="qa_distance_overall">
					<para>List the overall traveled distances of the cars during the periods from <varname>Periods</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T.VehId, P.PeriodId, P.Period, 
  SUM(length(atPeriod(T.Trip, P.Period))) AS Distance
FROM Trips T, Periods P
WHERE T.Trip &amp;&amp; P.Period
GROUP BY T.VehId, P.PeriodId, P.Period
ORDER BY T.VehId, P.PeriodId;
</programlisting>
					<para>The query performs a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on the <varname>Trips</varname> table. It then projects the trip to the period, computes the length of the projected trip, and sum the lengths of all the trips of the same car during the period.</para>
				</listitem>

				<listitem id="qa_distance_static">
					<para>List the minimum distance ever between each car and each point from <varname>Points</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T.VehId, P.PointId, MIN(trajectory(T.Trip) &lt;-&gt; P.Geom) AS MinDistance
FROM Trips T, Points P
GROUP BY T.VehId, P.PointId
ORDER BY T.VehId, P.PointId;
</programlisting>
					<para>The query projects the trip to the spatial dimension with the <varname>trajectory</varname> function and computes the traditional distance between the trajectory of the trip and the point. The traditional minimum function is then applied for computing the minimum distance between all trips of the car and the point.</para>
				</listitem>

				<listitem id="qa_distance_moving">
					<para>List the minimum temporal distance between each pair of cars.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T1.VehId AS Car1Id, T2.VehId AS Car2Id, MIN(T1.Trip &lt;-&gt; T2.Trip) AS MinDistance
FROM Trips T1, Trips T
WHERE T1.VehId &lt; T2.VehId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
GROUP BY T1.VehId, T2.VehId
ORDER BY T1.VehId, T2.VehId;
</programlisting>
					<para>The query selects two trips <varname>T1</varname> and <varname>T2</varname> from different cars that were both traveling during a common period of time, computes the temporal distance between the trips, and then computes the temporal minimum distance between all trips of the two cars. The query uses the spatio-temporal index to filter the pairs of trips that were both traveling during a common period of time.</para>
				</listitem>

				<listitem id="qa_nearest_approach">
					<para>List the nearest approach time, distance, and shortest line between each pair of trips.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T1.VehId AS Car1Id, T1.TripId AS Trip1Id, T2.VehId AS Car2Id, 
  T2.TripId AS Trip2Id, period(NearestApproachInstant(T1.Trip, T2.Trip)) AS Time,
  NearestApproachDistance(T1.Trip, T2.Trip) AS Distance, 
  ShortestLine(T1.Trip, T2.Trip) AS Line
FROM Trips1 T1, Trips1 T
WHERE T1.VehId &lt; T2.VehId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
ORDER BY T1.VehId, T1.TripId, T2.VehId, T2.TripId;
</programlisting>
					<para>This query shows similar functionality as that provided by the PostGIS functions <varname>ST_ClosestPointOfApproach</varname> and <varname>ST_DistanceCPA</varname>. The query selects two trips <varname>T1</varname> and <varname>T2</varname> from different cars that were both traveling during a common period of time and computes the required results.</para>
				</listitem>

				<listitem id="qa_distance_tdwithin">
					<para>List when and where a pairs of cars have been at 10 m or less from each other.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T1.VehId AS VehId1, T2.VehId AS VehId2, atPeriodSet(T1.Trip,
  period(atValue(tdwithin(T1.Trip, T2.Trip, 10.0), TRUE))) AS Position
FROM Trips T1, Trips T
WHERE T1.VehId &lt; T2.VehId AND T1.Trip &amp;&amp; expandSpatial(T2.Trip, 10) AND
  atPeriodSet(T1.Trip, period(atValue(tdwithin(T1.Trip, T2.Trip, 10.0), TRUE))) 
  IS NOT NULL
ORDER BY T1.VehId, T2.VehId, Position;
</programlisting>
					<para>The query performs for each pair of trips <varname>T1</varname> and <varname>T2</varname> of different cars a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on the <varname>Trips</varname> table, where the bounding box of <varname>T2</varname> is expanded by 10 m. Then, the <varname>period</varname> expression computes the periods during which the cars were within 10 m. from each other and the <varname>atPeriodSet</varname> function projects the trips to those periods. Notice that the expression <varname>tdwithin(T1.Trip, T2.Trip, 10.0)</varname> is conceptually equivalent to <varname>dwithin(T1.Trip, T2.Trip) #&lt;= 10.0</varname>. However, in this case the spatio-temporal index cannot be used for filtering values.</para>
				</listitem>
			</orderedlist>
		</sect2>

		<sect2>
			<title>Nearest-Neighbor Queries</title>
			<para>There are three common types of nearest-neighbor queries in spatial databases.
				<itemizedlist>
					<listitem>
						<para>k-nearest-neighbor (kNN) queries find the k nearest points to a given point.</para>
					</listitem>

					<listitem>
						<para>Reverse k-nearest-neighbor (RkNN) queries find the points that have a given point among their k nearest-neighbors.</para>
					</listitem>

					<listitem>
						<para>Given two sets of points P and Q, aggregate nearest-neighbor (ANN) queries find the points from P that have minimum aggregated distance to all points from Q.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>The above types of queries are generalized to temporal points. However, the complexity of these queries depend on whether the reference object and the candidate objects are static or moving. In the examples that follow we only consider the nontemporal version of the nearest-neighbor queries, that is, the one in which the calculation is performed on the projection of temporal points on the spatial dimension. The temporal version of the nearest-neighbor queries remains to be done.</para>

			<orderedlist continuation="continues">
				<listitem id="qa_knn_static">
					<para>For each trip from <varname>Trips</varname>, list the three points from <varname>Points</varname> that have been closest to that car.</para>
					<programlisting language="sql" xml:space="preserve">
WITH TripsTraj AS (
  SELECT *, trajectory(Trip) AS Trajectory FROM Trips )
SELECT T.VehId, P1.PointId, P1.Distance
FROM TripsTraj T CROSS JOIN LATERAL (
  SELECT P.PointId, T.Trajectory &lt;-&gt; P.Geom AS Distance
  FROM Points P
  ORDER BY Distance LIMIT 3 ) AS P1
ORDER BY T.TripId, T.VehId, P1.Distance;
</programlisting>
					<para>This is a nearest-neighbor query with moving reference objects and static candidate objects. The query above uses PostgreSQL's lateral join, which intuitively iterates over each row in a result set and evaluates a subquery using that row as a parameter. The query starts by computing the trajectory of the trips in the temporary table <varname>TripsTraj</varname>. Then, given a trip <varname>T</varname> in the outer query, the subquery computes the traditional distance between the trajectory of <varname>T</varname> and each point <varname>P</varname>. The <varname>ORDER BY</varname> and <varname>LIMIT</varname> clauses in the inner query select the three closest points. PostGIS will use the spatial index on the <varname>Points</varname> table for selecting the three closest points.</para>
				</listitem>

				<listitem id="qa_knn_moving">
					<para>For each trip from <varname>Trips</varname>, list the three cars that are closest to that car</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T1.VehId AS VehId1, C2.VehId AS VehId2, C2.Distance
FROM Trips T1 CROSS JOIN LATERAL (
  SELECT T2.VehId, minValue(T1.Trip &lt;-&gt; T2.Trip) AS Distance
  FROM Trips T2
  WHERE T1.VehId &lt; T2.VehId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
  ORDER BY Distance LIMIT 3 ) AS C2
ORDER BY T1.VehId, C2.VehId;
</programlisting>
					<para>This is a nearest-neighbor query where both the reference and the candidate objects are moving. Therefore, it is not possible to proceed as in the previous query to first project the moving points to the spatial dimension and then compute the traditional distance. Given a trip <varname>T1</varname> in the outer query, the subquery computes the temporal distance between <varname>T1</varname> and a trip <varname>T2</varname> of another car different from the car from <varname>T1</varname> and then computes the minimum value in the temporal distance. Finally, the <varname>ORDER BY</varname> and <varname>LIMIT</varname> clauses in the inner query select the three closest cars.</para>
				</listitem>

				<listitem id="qa_rknn_static">
					<para>For each trip from <varname>Trips</varname>, list the points from <varname>Points</varname> that have that car among their three nearest neighbors.</para>
					<programlisting language="sql" xml:space="preserve">
WITH TripsTraj AS (
  SELECT *, trajectory(Trip) AS Trajectory FROM Trips ),
PointTrips AS (
  SELECT P.PointId, T2.VehId, T2.TripId, T2.Distance
  FROM Points P CROSS JOIN LATERAL (
    SELECT T1.VehId, T1.TripId, P.Geom &lt;-&gt; T1.Trajectory AS Distance
    FROM TripsTraj T
    ORDER BY Distance LIMIT 3 ) AS T2 )
SELECT T.VehId, T.TripId, P.PointId, PT.Distance
FROM Trips T CROSS JOIN Points P JOIN PointTrips PT
  ON T.VehId = PT.VehId AND T.TripId = PT.TripId AND P.PointId = PT.PointId
ORDER BY T.VehId, T.TripId, P.PointId;
</programlisting>
					<para>This is a reverse nearest-neighbor query with moving reference objects and static candidate objects. The query starts by computing the corresponding nearest-neighbor query in the temporary table <varname>PointTrips</varname> as it is done in Query 13. Then, in the main query it verifies for each trip <varname>T</varname> and point <varname>P</varname> that both belong to the <varname>PointTrips</varname> table.</para>
				</listitem>

				<listitem id="qa_rknn_moving">
					<para>For each trip from <varname>Trips</varname>, list the cars having the car of the trip among the three nearest neighbors.</para>
					<programlisting language="sql" xml:space="preserve">
WITH TripDistances AS (
  SELECT T1.VehId AS VehId1, T1.TripId AS TripId1, T3.VehId AS VehId2, 
    T3.TripId AS TripId2, T3.Distance
  FROM Trips T1 CROSS JOIN LATERAL (
    SELECT T2.VehId, T2.TripId, minValue(T1.Trip &lt;-&gt; T2.Trip) AS Distance
    FROM Trips T
    WHERE T1.VehId &lt; T2.VehId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
    ORDER BY Distance LIMIT 3 ) AS T3 )
SELECT T1.VehId, T1.TripId, T2.VehId, T2.TripId, TD.Distance
FROM Trips T1 JOIN Trips T2 ON T1.VehId &lt; T2.VehId
  JOIN TripDistances TD ON T1.VehId = TD.VehId1 AND T1.TripId = TD.TripId1 AND
  T2.VehId = TD.VehId2 AND T2.TripId = TD.TripId
ORDER BY T1.VehId, T1.TripId, T2.VehId, T2.TripId;
</programlisting>
					<para>This is a reverse nearest-neighbor query where both the reference and the candidate objects are moving. The query starts by computing the corresponding nearest-neighbor query in the temporary table <varname>TripDistances</varname> as it is done in Query 14. Then, in the main query it verifies for each pair of trips <varname>T1</varname> and <varname>T2</varname> that both belong to the <varname>TripDistances</varname> table.</para>
				</listitem>

				<listitem id="qa_ann">
					<para>For each group of ten disjoint cars, list the point(s) from <varname>Points</varname>, having the minimum aggregated distance from the given group of ten cars during the given period.</para>
					<programlisting language="sql" xml:space="preserve">
WITH Groups AS (
  SELECT ((ROW_NUMBER() OVER (ORDER BY V.VehId))-1)/10 + 1 AS GroupId, V.VehId
  FROM Vehicles V ),
SumDistances AS (
  SELECT G.GroupId, P.PointId,
    SUM(ST_Distance(trajectory(T.Trip), P.Geom)) AS SumDist
  FROM Groups G, Points P, Trips T
  WHERE T.VehId = G.VehId
  GROUP BY G.GroupId, P.PointId )
SELECT S1.GroupId, S1.PointId, S1.SumDist
FROM SumDistances S
WHERE S1.SumDist &lt;= ALL (
  SELECT SumDist
  FROM SumDistances S
  WHERE S1.GroupId = S2.GroupId )
ORDER BY S1.GroupId, S1.PointId;
</programlisting>
					<para>This is an aggregate nearest-neighbor query. The temporary table <varname>Groups</varname> splits the cars in groups where the <varname>GroupId</varname> column takes the values from 1 to total number of groups. The temporary table <varname>SumDistances</varname> computes for each group <varname>G</varname> and point <varname>P</varname> the sum of the distances between a trip of a car in the group and the point. The main query then selects for each group in table <varname>SumDistances</varname> the points(s) that have the minimum aggregated distance.</para>
				</listitem>
			</orderedlist>
		</sect2>
	</sect1>
</chapter>
