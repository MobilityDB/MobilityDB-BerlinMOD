<?xml version="1.0" encoding="UTF-8"?>
<chapter id="tutorial">
	<title>MobilityDB Tutorial</title>
	<para>
		To illustrate the capabilities of MobilityDB, we give an example use case that loads, explores, and query mobility data. The data used is based on the MobilityDB <ulink url="https://github.com/MobilityDB/MobilityDB-BerlinMOD">implementation</ulink> of the <ulink url="http://dna.fernuni-hagen.de/secondo/BerlinMOD/BerlinMOD.html">BerlinMOD</ulink> benchmark for moving object databases. The data is available as a <ulink url="https://docs.mobilitydb.com/data/berlinmod_data.zip">ZIP</ulink> file.
	</para>

	<sect1>
		<title>Installation</title>

		<para>
			For this tutorial we can use two alternative installations:
			<itemizedlist>
				<listitem><para>Install from sources</para></listitem>
				<listitem><para>Use a Docker image containing MobilityDB and all its dependencies (including PostgreSQL and PostGIS)</para></listitem>
			</itemizedlist>
		We explain first the installation from sources and later in this section we explain the installation using a Docker image.
		</para>

		<para>
			In order to use this tutorial you must first have MobilityDB installed in your system. We refer to the MobilityDB <ulink url="https://github.com/MobilityDB/MobilityDB">documentation</ulink> for doing this task. Then we can install the MobilityDB-BerlinMOD tutorial as follows.
				<programlisting language="bash" xml:space="preserve">
git clone https://github.com/MobilityDB/MobilityDB-BerlinMOD.git
cd MobilityDB-BerlinMOD/BerlinMOD
</programlisting>
		</para>

		<para>
		We explain now how to explore this tutorial using a Docker image that contains MobilityDB and all its dependencies (including PostgreSQL and PostGIS). The container has a default database called <varname>mobilitydb</varname> with the MobilityDB extension installed where <varname>user = pw = docker</varname>. This presupposes that you have installed Docker into your computer. In that case, you can run the following command.
			<programlisting language="bash" xml:space="preserve">
docker pull codewit/mobilitydb
docker volume create mobilitydb_data
docker run --name "mobilitydb" -d -p 25432:5432 -v mobilitydb_data:/var/lib/postgresql 
codewit/mobilitydb
</programlisting>
			In the above commands
			<itemizedlist>
				<listitem><para><varname>docker pull</varname> downloads the Docker image of <varname>mobilitydb</varname>. If the image has been downloaded before, this checks whether a more recent image has been published in the docker repository, and downloads it. It is better to call this command every time, to ensures that you have the latest most up-to-date version of this image.</para></listitem>

				<listitem><para><varname>docker volume create mobilitydb_data</varname> creates a volume container on the host, that we will use to persist the PostgreSQL database files outside of the MobilityDB container. You need to run this command only once, during the first use of the image</para>
				</listitem>

				<listitem><para><varname>docker run --name=mobilitydb</varname> tells Docker our new container will be named <varname>mobilitydb</varname>.</para></listitem>

				<listitem><para><varname>-d</varname> runs the container in the background (detached mode).</para></listitem>

				<listitem><para><varname>-p 25432:5432</varname> maps TCP port 5432 in the container to port 25432 on the Docker host (to prevent potential conflicts with any local database instance you may have). This is required because the PostgreSQL database server in the container listens for connections on port 5432 by default.</para>
				</listitem>

				<listitem><para><varname>-v mobilitydb_data:/var/lib/postgresql</varname> tells the container filesystem to mount the <varname>mobilitydb_data</varname> volume that we have just created to the path /var/lib/postgresql. This means that any database objects that the container saves or creates (by default in <varname>/var/lib/postgresql</varname>) will instead be persisted in the <varname>mobilitydb_data</varname> directory, which is stored in the host. This options ensures that your data will not be lost when the container is removed. </para>
				</listitem>

				<listitem><para><varname>codewit/mobilitydb</varname> tells Docker to pull the docker image with that name from Docker Hub.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>
		Now we can launch any PostgreSQL administrative front-end to start using MobilityDB. Two traditional ones are the command-line tool <varname>psql</varname> and the graphical tool <varname>pgAdmin</varname>. We can launch <varname>psql</varname> as follows.
			<programlisting language="bash" xml:space="preserve">
docker exec -t -i mobilitydb psql -h localhost -p 5432 -d mobilitydb -U docker
</programlisting>
			In the above command
			<itemizedlist>
				<listitem><para><varname>docker exec -t -i mobilitydb psql</varname> tells Docker to allocate a pseudo-TTY, to keep STDIN open, and to execute in the container <varname>mobilitydb</varname> the command <varname>psql</varname>.</para></listitem>

				<listitem><para><varname>-h localhost -p 5432 -d mobilitydb -U docker</varname> tells <varname>psql</varname>, respectively, the database server host, the server port, the database name, and the user name.</para></listitem>
			</itemizedlist>
			Note that you will be prompted to provide the password, which is also <varname>docker</varname>.
		</para>

		<para>
		In order to launch <varname>pgAdmin</varname>, there are two options to create a connection. The first option is to set the host to the localhost (127.0.0.1), and the port to the mapped one on the host, as per the <varname>docker run</varname> command. In this example the port is 25432. Now we can launch <varname>pgAdmin</varname> and establish a new connection to the docker container. This is done as shown in <xref linkend="pgAdmin" />. 
		</para>

		<figure id="pgAdmin" float="start"><title>Configuration of a connection to the docker image in pgAdmin.</title>
			<mediaobject>
				<imageobject><imagedata scale='50' fileref='images/pgAdmin.png' /></imageobject>
			</mediaobject>
		</figure>

		<para>
		The second option is to know the IP address used by docker container with the following command.
			<programlisting language="bash" xml:space="preserve">
docker-machine ip
-- 192.168.99.101
</programlisting>
			Notice that the address obtained in your computer may be different from the one above. Now we can launch <varname>pgAdmin</varname> and establish a new connection to the docker container. This is done as shown in <xref linkend="pgAdmin" />. The second option is to set the host to the localhost (127.0.0.1), and the port to the mapped one on the host, as per the <varname>docker run</varname> command. In this example the port would be 25432.
		</para>

		<para>
		Now you can use pgAdmin to query the mobilitydb database, as will be further explained in the following sections. Here are few more docker commands that you will eventually need:
		<programlisting language="bash" xml:space="preserve">
docker stop "mobilitydb"
docker start "mobilitydb"
docker rm "mobilitydb"
</programlisting>
			The above commands
			<itemizedlist>
				<listitem>
					<para><varname>docker stop</varname> shuts down the docker container. You need to issue this command, for example, if you need to re-start the host.</para>
				</listitem>
				<listitem>
					<para><varname>docker start</varname> launches back the docker container. You need to issue this command, for example, after re-starting the host.</para>
				</listitem>

				<listitem>
					<para><varname>docker rm</varname> removes/deletes docker container. You need to issue this command, for example, if you need to <varname>docker pull</varname> a more recent MobilityDB image. If the databases are stored in a <varname>docker volume</varname> as explained above, it will still be available after downloading and running the new image.</para>
				</listitem>
			</itemizedlist>
		</para>
	</sect1>

	<sect1>
		<title>Loading the Data</title>

		<para>The ZIP file with the data for this tutorial contains a set of CSV files as follows:
			<itemizedlist>
				<listitem>
					<para><varname>instants.csv</varname> with fields <varname>InstantId</varname> and <varname>Instant</varname> contains timestamps used for queries.</para>
				</listitem>

				<listitem>
					<para><varname>licences.csv</varname> with fields <varname>LicenceId</varname>, <varname>Licence</varname> and <varname>VehId</varname> contains vehicle licences used for queries.</para>
				</listitem>

				<listitem>
					<para><varname>periods.csv</varname> with fields <varname>PeriodId</varname>, <varname>Begin</varname>, and <varname>End</varname> contains periods used for the queries.</para>
				</listitem>

				<listitem>
					<para><varname>points.csv</varname> with fields <varname>PointId</varname>, <varname>PosX</varname>, and <varname>PosY</varname> contains points used for queries.</para>
				</listitem>

				<listitem>
					<para><varname>regions.csv</varname> with fields <varname>RegionId</varname>, <varname>PointNo</varname>, <varname>PosX</varname>, and <varname>PosY</varname> and <varname>Yend</varname> contains the polygons used for queries.</para>
				</listitem>

				<listitem>
					<para><varname>trips.csv</varname> with fields <varname>TripId</varname>, <varname>VehId</varname>, <varname>PosX</varname>, <varname>PosY</varname>, and <varname>Instant</varname> contains vehicles movements and pauses.</para>
				</listitem>

				<listitem>
					<para><varname>vehicles.csv</varname> with fields <varname>VehId</varname>, <varname>Licence</varname>, <varname>Type</varname>, and <varname>Model</varname> contains the vehicle descriptions.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>
		We decompress the file with the data into a directory. This can be done using the command. 
			<programlisting language="bash" xml:space="preserve">
unzip berlinmod_data.zip
</programlisting>
		We suppose in the following that the directory used is as follows <varname>/home/mobilitydb/data/</varname>.
		</para>

		<para>
		In the following, we can use the <varname>mobilitydb</varname> database provided in the container. This database has already installed the MobilityDB extension. Alternatively, you may use another database. In that case, you can install the MobilityDB extension in your database by using the following command.
			<programlisting language="sql" xml:space="preserve">
CREATE EXTENSION MobilityDB CASCADE;
</programlisting>
		By using <varname>CASCADE</varname> we load the required PostGIS extension prior to loading MobilityDB.
		</para>

		<para>We create the tables to be loaded with the data in the CSV files as follows.
			<programlisting language="sql" xml:space="preserve">
CREATE TABLE Instants (
  InstantId integer PRIMARY KEY,
  Instant timestamptz NOT NULL
  );
CREATE TABLE Periods (
  PeriodId integer PRIMARY KEY,
  Tstart TimestampTz NOT NULL,
  Tend TimestampTz NOT NULL,
  Period period
  );
CREATE TABLE Points (
  PointId integer PRIMARY KEY,
  PosX double precision NOT NULL,
  PosY double precision NOT NULL,
  Geom Geometry(Point)
  );
CREATE TABLE RegionsInput (
  RegionId integer,
  PointNo integer,
  XPos double precision NOT NULL,
  YPos double precision NOT NULL,
  PRIMARY KEY (RegionId, PointNo)
  );
CREATE TABLE Regions (
  RegionId integer PRIMARY KEY,
  Geom Geometry(Polygon) NOT NULL
  );
CREATE TABLE Vehicles (
  VehId integer PRIMARY KEY,
  Licence text NOT NULL,
  Type text NOT NULL,
  Model text NOT NULL
  );
CREATE TABLE Licences (
  LicenceId integer PRIMARY KEY,
  Licence text NOT NULL,
  VehId integer NOT NULL REFERENCES Vehicles(VehId)
  );
CREATE TABLE TripsInput (
  TripId integer NOT NULL,
  VehId integer NOT NULL REFERENCES Vehicles(VehId),
  PosX float NOT NULL,
  PosY float NOT NULL,
  T timestamptz NOT NULL,
  PRIMARY KEY (TripId, T)
  );
CREATE TABLE Trips (
  TripId integer PRIMARY KEY,
  VehId integer NOT NULL REFERENCES Vehicles(VehId),
  Trip tgeompoint NOT NULL
  );
</programlisting>
		We created one table for each CSV file. In addition, we created a table <varname>Regions</varname> in order to assemble all points composing the polygon  of a region into a single geometry and a table <varname>Trips</varname> in order to assemble all instants composing a trip into a single temporal point.
		</para>

		<para>
		We can load the CSV files into the corresponding tables as follows.
			<programlisting language="sql" xml:space="preserve">
COPY Instants(InstantId, Instant) FROM '/home/mobilitydb/data/instants.csv' 
  DELIMITER ',' CSV HEADER;
COPY Periods(PeriodId, Tstart, Tend) FROM '/home/mobilitydb/data/periods.csv' 
  DELIMITER ',' CSV HEADER;
UPDATE Periods
SET Period = period(Tstart, Tend);
COPY Points(PointId, PosX, PosY) FROM '/home/mobilitydb/data/points.csv' 
  DELIMITER ',' CSV HEADER;
UPDATE Points
SET Geom = ST_Transform(ST_SetSRID(ST_MakePoint(PosX, PosY), 4326), 5676);
COPY RegionsInput(RegionId, PointId, XPos, YPos) FROM 
  '/home/mobilitydb/data/regions.csv' DELIMITER  ',' CSV HEADER;
COPY Vehicles(VehId, Licence, Type, Model) FROM '/home/mobilitydb/data/vehicles.csv' 
  DELIMITER ',' CSV HEADER;
COPY Licences(LicenceId, Licence, VehId) FROM '/home/mobilitydb/data/licences.csv' 
  DELIMITER ',' CSV HEADER;
COPY TripsInput(TripId, VehId, PosX, PosY, T) FROM '/home/mobilitydb/data/trips.csv' 
  DELIMITER ',' CSV HEADER;
</programlisting>
		</para>

		<para>The following query is used to load table <varname>Regions</varname> from the data in table <varname>RegionsInput</varname>.
			<programlisting language="sql" xml:space="preserve">
INSERT INTO Regions(RegionId, Geom)
SELECT RegionId, ST_MakePolygon(ST_MakeLine(array_agg(
  ST_Transform(ST_SetSRID(ST_MakePoint(PosX, PosY), 4326), 5676) ORDER BY PointNo)))
FROM RegionsInput
GROUP BY RegionId;
</programlisting>
		There are many nested functions, so reading from the innermost:
			<itemizedlist>
				<listitem>
					<para>Function <varname>ST_MakePoint</varname> construct a point from the <varname>PosX</varname> and <varname>PosY</varname> values.</para>
				</listitem>
				<listitem>
					<para>Function <varname>ST_SetSRID</varname> sets the SRID of the point to 4326, that is, to the standard WGS84 GPS coordinates.</para>
				</listitem>
				<listitem>
					<para>Function <varname>ST_Transform</varname> transforms the spherical GPS coordinates to plannar coordinates fitted for Belgium.</para>
				</listitem>
				<listitem>
					<para>Function <varname>array_agg</varname> collects in an array all points of a region (as specified by the <varname>GROUP BY</varname> clause) and sort them by  <varname>PointNo</varname> (as specified by the <varname>ORDER BY</varname> clause).</para>
				</listitem>
				<listitem>
					<para>Function <varname>ST_MakeLine</varname> make a linestring from the array of all points in a region.</para>
				</listitem>
				<listitem>
					<para>Function <varname>ST_MakePolygon</varname> make a polygon for the region from a linestring.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>The following query is used to load table <varname>Trips</varname> from the data in table <varname>TripsInput</varname>.
			<programlisting language="sql" xml:space="preserve">
INSERT INTO Trips(TripId, VehId, Trip)
SELECT TripId, VehId, tgeompoint_seq(array_agg(tgeompoint_inst(
  ST_Transform(ST_SetSRID(ST_MakePoint(PosX, PosY), 4326), 5676), T) ORDER BY T))
FROM TripsInput
GROUP BY VehId, TripId;
</programlisting>
		There are many nested functions, so reading from the innermost:
			<itemizedlist>
				<listitem>
					<para>Function <varname>ST_MakePoint</varname> construct a point from the <varname>PosX</varname> and <varname>PosY</varname> values.</para>
				</listitem>
				<listitem>
					<para>Function <varname>ST_SetSRID</varname> sets the SRID of the point to 4326.</para>
				</listitem>
				<listitem>
					<para>Function <varname>ST_Transform</varname> transforms the spherical coordinates to plannar coordinates with SRID 5676.</para>
				</listitem>
				<listitem>
					<para>Function <varname>tgeompoint_inst</varname> gets the point and the time values to create a temporal point of instant duration.</para>
				</listitem>
				<listitem>
					<para>Function <varname>array_agg</varname> collects in an array all temporal instant points of a given vehicle and a given trip (as specified by the <varname>GROUP BY</varname> clause) and sort them by time (as specified by the <varname>ORDER BY</varname> clause).</para>
				</listitem>
				<listitem>
					<para>Function <varname>tgeompoint_seq</varname> gets the array of temporal points and construct a temporal sequence point.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>Finally, we create indexes on traditional, spatial, temporal or spatiotemporal attributes as well as views to select a subset of the rows from the corresponding tables. This can be done as follows.
			<programlisting language="sql" xml:space="preserve">
CREATE INDEX Instants_Instant_Idx ON Instants USING btree(Instant);
CREATE INDEX Periods_Period_Idx ON Periods USING gist(Period);
CREATE INDEX Points_Geom_Idx ON Points USING gist(Geom);
CREATE INDEX Regions_Geom_Idx ON Regions USING gist(Geom);
CREATE INDEX Trips_VehId_Idx ON Trips USING btree(VehId);
CREATE INDEX Trips_Trip_gist_Idx ON Trips USING gist(trip);

CREATE VIEW Instants1 AS SELECT * FROM Instants LIMIT 10;
CREATE VIEW Periods1 AS SELECT * FROM Periods LIMIT 10;
CREATE VIEW Points1 AS SELECT * FROM Points LIMIT 10;
CREATE VIEW Regions1 AS SELECT * FROM Regions LIMIT 10;
CREATE VIEW Vehicles1 AS SELECT * FROM Vehicles LIMIT 10;
CREATE VIEW Trips1 AS SELECT * FROM Trips LIMIT 100;
</programlisting>
		</para>
	</sect1>

	<sect1>
		<title>Loading the Data in Partitioned Tables</title>
		<para>
		PostgreSQL provides partitioning mechanisms so that large tables can be split in smaller physical tables. This may result in increased performance when querying and manipulating large tables. We will split the <varname>Trips</varname> table given in the previous section using list partitioning, where each partitition will contain all the trips that start at a particular date. For doing this, we use the procedure given next for automatically creating the partitions according to a date range.
		</para>
		<programlisting language="sql" xml:space="preserve">
CREATE OR REPLACE FUNCTION create_partitions_by_date(TableName TEXT, StartDate DATE,
  EndDate DATE)
RETURNS void AS $$
DECLARE
  d DATE;
  PartitionName TEXT;
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.tables 
    WHERE table_name = lower(TableName)) 
  THEN
    RAISE EXCEPTION 'Table % does not exist', TableName;
  END IF;
  IF StartDate &gt;= EndDate THEN
    RAISE EXCEPTION 'The start date % must be before the end date %', StartDate, EndDate;
  END IF;
  d = StartDate;
  WHILE d &lt;= EndDate 
  LOOP
    PartitionName = TableName || '_' || to_char(d, 'YYYY_MM_DD');
    IF NOT EXISTS (
      SELECT 1
       FROM information_schema.tables 
       WHERE  table_name = lower(PartitionName))
    THEN
      EXECUTE format('CREATE TABLE %s PARTITION OF %s FOR VALUES IN (''%s'');', 
        PartitionName, TableName, to_char(d, 'YYYY-MM-DD'));
      RAISE NOTICE 'Partition % has been created', PartitionName;
    END IF;
    d = d + '1 day'::interval;
  END LOOP;
  RETURN;
END
$$ LANGUAGE plpgsql;
</programlisting>

		<para>In order to partition table <varname>Trips</varname> by date we need to add an addition column <varname>TripDate</varname> to table <varname>TripsInput</varname>.
			<programlisting language="sql" xml:space="preserve">
ALTER TABLE TripsInput ADD COLUMN TripDate DATE;
UPDATE TripsInput T1 
SET TripDate = T2.TripDate
FROM (SELECT DISTINCT TripId, date_trunc('day', MIN(T) OVER (PARTITION BY TripId))
AS TripDate FROM TripsInput) T2
WHERE T1.TripId = T2.TripId;
</programlisting>
		Notice that the <varname>UPDATE</varname> statement above takes into account the fact that a trip may finish at a day later than the starting day.
		</para>

		<para>
		The following statements create table <varname>Trips</varname> partitioned by date and the associated partitions.
			<programlisting language="sql" xml:space="preserve">
DROP TABLE Trips CASCADE;
CREATE TABLE Trips (
  TripId integer,
  TripDate date,
  VehId integer NOT NULL REFERENCES Vehicles(VehId),
  Trip tgeompoint NOT NULL,
  Traj geometry,
  PRIMARY KEY (TripId, TripDate)
) PARTITION BY LIST(TripDate);

SELECT create_partitions_by_date('Trips', (SELECT MIN(TripDate) FROM TripsInput), 
(SELECT MAX(TripDate) FROM TripsInput));
</programlisting>
		</para>

		<para>
		To see the partitions that have been created automatically we can use the following statement.
			<programlisting language="sql" xml:space="preserve">
SELECT I.inhrelid::regclass AS child
FROM pg_inherits I
WHERE i.inhparent = 'trips'::regclass;
</programlisting>
		In our case this would result in the following output.
			<programlisting language="sql" xml:space="preserve">
trips_2020_06_01
trips_2020_06_02
trips_2020_06_03
trips_2020_06_04
trips_2020_06_05
</programlisting>
		</para>

		<para>We modify the query that loads table <varname>Trips</varname> from the data in table <varname>TripsInput</varname> as follows.
			<programlisting language="sql" xml:space="preserve">
INSERT INTO Trips
SELECT TripId, TripDate, VehId, tgeompoint_seq(array_agg(tgeompoint_inst(
  ST_Transform(ST_SetSRID(ST_MakePoint(PosX,PosY), 4326), 5676), T) ORDER BY T))
FROM TripsInput
GROUP BY TripId, TripDate, VehId;
</programlisting>
		</para>

		<para>We can see how many trips are in each partition of the <varname>TripsInput</varname> as follows.
			<programlisting language="sql" xml:space="preserve">
SELECT COUNT(*) FROM trips_2020_06_01;
-- 423
SELECT COUNT(*) FROM trips_2020_06_02;
-- 411
SELECT COUNT(*) FROM trips_2020_06_03;
-- 415
SELECT COUNT(*) FROM trips_2020_06_04;
-- 419
SELECT COUNT(*) FROM trips_2020_06_05;
-- 4
</programlisting>
		Then, we can define the indexes and the views on the table <varname>Trips</varname> as shown in the previous section.
		</para>

		<para>
		An important advantange of the partitioning mechanism in PostgreSQL is that the constraints and the indexes defined on the <varname>Trips</varname> table are propagated to the partitions as shown next.
		</para>
		<programlisting language="sql" xml:space="preserve">
INSERT INTO Trips VALUES (1, '2020-06-01', 10,
  '[POINT(2389629.8979609837 5626986.483650829)@2020-06-02 08:00]');
-- ERROR:  duplicate key value violates unique constraint "trips_2020_06_01_pkey"
-- DETAIL:  Key (tripid, tripdate)=(1, 2020-06-01) already exists.
</programlisting>

		<para>
			Similarly, queries on the <varname>Trips</varname> table are propagated to the partitions as shown next.
		</para>
		<programlisting language="sql" xml:space="preserve">
EXPLAIN SELECT COUNT(*) FROM Trips WHERE Trip &amp;&amp; period '[2020-06-02, 2020-06-03)';
</programlisting>

		<para>
			If there is no index defined on the <varname>Trip</varname> column, the execution plan of the query is as follows:
		<programlisting language="sql" xml:space="preserve">
Aggregate (cost=63.64..63.65 rows=1 width=8)
-> Append (cost=0.00..63.62 rows=5 width=0)
   -> Seq Scan on trips_2020_06_01 trips_1  (cost=0.00..11.29 rows=1 width=0)
        Filter: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
   -> Seq Scan on trips_2020_06_02 trips_2  (cost=0.00..11.14 rows=1 width=0)
        Filter: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
   -> Seq Scan on trips_2020_06_03 trips_3  (cost=0.00..11.19 rows=1 width=0)
        Filter: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
   -> Seq Scan on trips_2020_06_04 trips_4  (cost=0.00..10.24 rows=1 width=0)
        Filter: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
   -> Seq Scan on trips_2020_06_05 trips_5  (cost=0.00..19.75 rows=1 width=0)
        Filter: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
</programlisting>
			After defining an index on the <varname>Trip</varname> column as follows
			<programlisting language="sql" xml:space="preserve">
CREATE INDEX Trips_Trip_gist_Idx ON Trips USING gist (Trip);
</programlisting>
			the execution plan of the query is as follows
		<programlisting language="sql" xml:space="preserve">
Aggregate (cost=33.73..33.74 rows=1 width=8)
-> Append (cost=0.14..33.71 rows=5 width=0)
   -> Index Scan using trips_2020_06_01_trip_idx on trips_2020_06_01 trips_1
      (cost=0.14..8.16 rows=1 width=0)
        Index Cond: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
   -> Index Scan using trips_2020_06_02_trip_idx on trips_2020_06_02 trips_2
      (cost=0.14..8.16 rows=1 width=0)
        Index Cond: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
   -> Index Scan using trips_2020_06_03_trip_idx on trips_2020_06_03 trips_3
      (cost=0.14..8.16 rows=1 width=0)
        Index Cond: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
   -> Index Scan using trips_2020_06_04_trip_idx on trips_2020_06_04 trips_4
      (cost=0.14..8.16 rows=1 width=0)
        Index Cond: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
   -> Seq Scan on trips_2020_06_05 trips_5  (cost=0.00..1.05 rows=1 width=0)
        Filter: (trip &amp;&amp; '[2020-06-02 00:00:00+02, 2020-06-03 00:00:00+02)'::period)
</programlisting>
		</para>
	</sect1>

	<sect1>
		<title>Exploring the Data</title>
		<para>In order to visualize the data with traditional tools such as <ulink url="https://qgis.org/">QGIS</ulink> we add to table <varname>Trip</varname> a column <varname>Traj</varname> of type <varname>geometry</varname> containing the trajectory of the trips.
			<programlisting language="sql" xml:space="preserve">
ALTER TABLE Trips ADD COLUMN traj geometry;
UPDATE Trips
SET Traj = trajectory(Trip);
</programlisting>
		The visualization of the trajectories in QGIS is given in <xref linkend="berlinmod_trips" />. In the figure red lines correspond to the trajectories of moving vehicles, while yellow points correspond to the position of stationary vehicles. In order to know the total number of trips as well as the number of moving and stationary trips we can issue the following queries.
			<programlisting language="sql" xml:space="preserve">
SELECT count(*) FROM Trips;
-- 1672
SELECT count(*) FROM Trips WHERE GeometryType(Traj) = 'POINT';
-- 0
SELECT count(*) FROM Trips WHERE GeometryType(Traj) = 'LINESTRING';
-- 1672
</programlisting>
		We can also determine the spatiotemporal extent of the data using the following query.
			<programlisting language="sql" xml:space="preserve">
SELECT extent(Trip) from Trips;
-- SRID=3857;STBOX XT(((469715.0960907607,6577078.768286072),
--    (500997.56505993055,6607214.0038881665)),
--    [2020-06-01 08:01:16.984+02, 2020-06-05 01:40:04.281127+02])
</programlisting>
		</para>

		<figure id="berlinmod_trips" float="start"><title>Visualization of the trajectories of the trips in QGIS.</title>
			<mediaobject>
				<imageobject><imagedata scalefit="1" fileref='images/berlinmod_trips.png' /></imageobject>
			</mediaobject>
		</figure>

		<para>
		We continue investigating the data set by computing the maximum number of concurrent trips over the whole period
			<programlisting language="sql" xml:space="preserve">
SELECT maxValue(tcount(Trip)) FROM Trips;
-- 51
</programlisting>
		the average sampling rate
			<programlisting language="sql" xml:space="preserve">
SELECT AVG(duration(Trip)/numInstants(Trip)) FROM Trips;
-- 00:00:01.370537
</programlisting>
			and the total travelled distance in kilometers of all trips:
			<programlisting language="sql" xml:space="preserve">
SELECT SUM(length(Trip)) / 1e3 as TotalLengthKm FROM Trips;
-- 24209.259034796323
</programlisting>
		</para>

		<para>
		Now we want to know the average duration of a trip.
			<programlisting language="sql" xml:space="preserve">
SELECT AVG(duration(Trip)) FROM Trips;
-- 00:25:09.065361
</programlisting>
		This following query tells us the length in kilometers and the duration of each trip.
			<programlisting language="sql" xml:space="preserve">
SELECT tripId, length(Trip) / 1e3 AS lengthKm, duration(Trip) AS duration
FROM Trips ORDER BY duration;
</programlisting>
		</para>

		<para>
		The following query produces a histogram of trip length.
			<programlisting language="sql" xml:space="preserve">
WITH buckets (bucketNo, bucketRange) AS (
  SELECT 1, floatspan '[0, 1)' UNION
  SELECT 2, floatspan '[1, 2)' UNION
  SELECT 3, floatspan '[2, 5)' UNION
  SELECT 4, floatspan '[5, 10)' UNION
  SELECT 5, floatspan '[10, 50)' UNION
  SELECT 6, floatspan '[50, 100)' ),
histogram AS (
  SELECT bucketNo, bucketRange, count(TripId) as freq
  FROM buckets left outer join trips on length(trip) / 1e3 &lt;@ bucketRange
  GROUP BY bucketNo, bucketRange
  ORDER BY bucketNo, bucketRange )
SELECT bucketNo, bucketRange, freq,
  repeat('&#9632;', ( freq::float / max(freq) OVER () * 30 )::int ) AS bar
FROM histogram;
</programlisting>
			The result of the above query is given next. 
			<programlisting language="sql" xml:space="preserve">
 bucketno | bucketrange | freq |              bar
----------+-------------+------+--------------------------------
        1 | [0, 1)      |   41 | &#9632;
        2 | [1, 2)      |   91 | &#9632;&#9632;&#9632;
        3 | [2, 5)      |  329 | &#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;
        4 | [5, 10)     |  294 | &#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;
        5 | [10, 50)    |  909 | &#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;
        6 | [50, 100)   |    8 |
</programlisting>
		</para>
	</sect1>

	<sect1>
		<title>Querying the Data</title>
		<para>We discuss next four categories of queries: range queries, distance queries, temporal aggregate queries, and nearest-neighbor queries.</para>

		<sect2>
			<title>Range Queries</title>
			<para>The queries in this category restrict Trips with respect to a spatial, temporal, or spatio-temporal point or range. In the examples, the spatial points and ranges are given, respectively, in tables <varname>Points</varname> and <varname>Regions</varname>, while temporal points and ranges are given, respectively, in tables <varname>Instants</varname> and <varname>Periods</varname>.</para>

			<orderedlist>
				<listitem id="qa_range_spatial">
					<para>List the vehicles that have passed at a region from <varname>Regions</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT DISTINCT R.RegionId, T.VehId
FROM Trips T, Regions R
WHERE ST_Intersects(trajectory(T.Trip), R.Geom)
ORDER BY R.RegionId, T.VehId;
</programlisting>
					<para>This is a spatial range query. The query verifies that the trajectory of the vehicle intersects the region. PostGIS performs an implicit bounding box comparison <varname>trajectory(T.Trip) &amp;&amp; R.Geom</varname> using the spatial index on table <varname>Regions</varname> when executing the predicate <varname>ST_Intersects</varname>.</para>
				</listitem>

				<listitem id="qa_range_spatiotemporal">
					<para>List the vehicles that were within a region from <varname>Regions</varname> during a period from <varname>Periods</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT R.RegionId, P.PeriodId, T.VehId
FROM Trips T, Regions R, Periods P
WHERE T.Trip &amp;&amp; stbox(R.Geom, P.Period) AND 
  intersects(atPeriod(T.Trip, P.Period), R.Geom)
ORDER BY R.RegionId, P.PeriodId, T.VehId;
</programlisting>
					<para>This is a spatio-temporal range query. The query performs a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on table <varname>Trips</varname>. After that, the query verifies that the location of the vehicle during the period intersects the region. Notice that the predicate <varname>_intersects</varname> is used instead of <varname>intersects</varname> to avoid an implicit index test with the bounding box comparison <varname>atPeriod(Trip, P.Period) &amp;&amp; R.Geom</varname> is performed using the spatio-temporal index.</para>
				</listitem>

				<listitem id="qa_range_spatiotemporal_join">
					<para>List the pairs of vehicles that were both located within a region from <varname>Regions</varname> during a period from <varname>Periods</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT DISTINCT T1.VehId AS VehId1, T2.VehId AS VehId2, R.RegionId, P.PeriodId
FROM Trips T1, Trips T2, Regions R, Periods P
WHERE T1.VehId &lt; T2.VehId AND T1.Trip &amp;&amp; stbox(R.Geom, P.Period) AND
  T2.Trip &amp;&amp; stbox(R.Geom, P.Period) AND 
  intersects(atPeriod(T1.Trip, P.Period), R.Geom) AND
  intersects(atPeriod(T2.Trip, P.Period), R.Geom)
ORDER BY T1.VehId, T2.VehId, R.RegionId, P.PeriodId;
</programlisting>
					<para>This is a spatio-temporal range join query. The query selects two trips of different vehicles and performs bounding box comparisons of each trip with a region and a period using the spatio-temporal index of the <varname>Trips</varname> table. The query then verifies that both vehicles were located within the region during the period.</para>
				</listitem>

				<listitem id="qa_range_entering">
					<para>List the first time at which a vehicle visited a point in <varname>Points</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T.VehId, P.PointId, MIN(startTimestamp(atValue(T.Trip,P.Geom))) AS Instant
FROM Trips T, Points P
WHERE ST_Contains(trajectory(T.Trip), P.Geom)
GROUP BY T.VehId, P.PointId;
</programlisting>
					<para>The query selects a trip and a point and verifies that the vehicle passed by the point by testing that the trajectory of the trip contains the point. Notice that PostGIS will perform the bounding box containment <varname>trajectory(T.Trip) ~ P.Geom</varname> using the spatial index on table <varname>Points</varname> before executing <varname>ST_Contains</varname>. Then, the query projects the trip to the point with the <varname>atValue</varname> function, get the first timestamp of the projected trip with the <varname>startTimestamp</varname> function, and applies the traditional <varname>MIN</varname> aggregate function for all trips of the vehicle and the point.</para>
				</listitem>
			</orderedlist>
		</sect2>

		<sect2>
			<title>Temporal Aggregate Queries</title>
			<para>There are three common types of temporal aggregate queries.
				<itemizedlist>
					<listitem>
						<para>Instant temporal aggregate queries in which, from a conceptual perspective, the traditional aggregate function is applied at each instant.</para>
					</listitem>

					<listitem>
						<para>Window temporal aggregate queries (also known as cumulative queries), which, given a time interval w, compute the value of the aggregate at a time instant t from the values during the time period [t-w, t].</para>
					</listitem>

					<listitem>
						<para>Span temporal aggregate queries, which, first, split the time line into predefined intervals independently of the target data, and then, for each of these intervals, aggregate the data that overlap the interval.</para>
					</listitem>
				</itemizedlist>
			</para>

			<orderedlist continuation="continues">
				<listitem id="qa_aggregate_instant">
					<para>Compute how many vehicles were active at each period in <varname>Periods</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT P.PeriodID, COUNT(*), TCOUNT(atPeriod(T.Trip, P.Period))
FROM Trips T, Periods P
WHERE T.Trip &amp;&amp; P.Period
GROUP BY P.PeriodID
ORDER BY P.PeriodID;
</programlisting>
					<para>This an instant temporal aggregate query. For each period, the query projects the trips to the given period and applies the temporal count to the projected trips. The condition in the <varname>WHERE</varname> clause is used for filtering the trips with the spatio-temporal index on table <varname>Trips</varname>.</para>
				</listitem>

				<listitem id="qa_aggregate_window">
					<para>For each region in <varname>Regions</varname>, give the window temporal count of trips with a 10-minute interval.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT R.RegionID, WCOUNT(atGeometry(T.Trip, R.Geom), interval '10 min')
FROM Trips T, Regions R
WHERE T.Trip &amp;&amp; R.Geom
GROUP BY R.RegionID
HAVING WCOUNT(atGeometry(T.Trip, R.Geom), interval '10 min') IS NOT NULL
ORDER BY R.RegionID;
</programlisting>
					<para>This is a window temporal aggregate query. Suppose that we are computing pollution levels by region. Since the effect of a vehicle passing at a location lasts some time interval, this is a typical case for window aggregates. For each region, the query computes the spatial projection of the trips to the given region and apply the window temporal count to the projected trips. The condition in the <varname>WHERE</varname> clause is used for filtering the trips with the spatio-temporal index. The condition in the <varname>HAVING</varname> clause is used for removing regions that do not intersect with any trip.</para>
				</listitem>

				<listitem id="qa_aggregate_span">
					<para>Count the number of trips that were active during each hour in May 29, 2007.</para>
					<programlisting language="sql" xml:space="preserve">
WITH TimeSplit(Period) AS (
  SELECT period(H, H + interval '1 hour')
  FROM generate_series(timestamptz '2007-05-29 00:00:00', 
    timestamptz '2007-05-29 23:00:00', interval '1 hour') AS H )
SELECT Period, COUNT(*)
FROM TimeSplit S, Trips T
WHERE S.Period &amp;&amp; T.Trip AND atPeriod(Trip, Period) IS NOT NULL
GROUP BY S.Period
ORDER BY S.Period;
</programlisting>
					<para>This is a span temporal aggregate query. The query defines the intervals to consider in the <varname>TimeSplit</varname> temporary table. For each of these intervals, the main query applies the traditional count function for counting the trips that overlap the interval.</para>
				</listitem>
			</orderedlist>
		</sect2>

		<sect2>
			<title>Distance Queries</title>
			<para>The queries in this category deal with either the distance travelled by a single object or the distance between two objects. The complexity of the latter queries depend, on the one hand, on whether the reference objects are static or moving, and on the other, on whether the operation required is either the minimum distance ever or the temporal distance computed at each instant.</para>

			<orderedlist continuation="continues">
				<listitem id="qa_distance_overall">
					<para>List the overall traveled distances of the vehicles during the periods from <varname>Periods</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T.VehId, P.PeriodId, P.Period,
  SUM(length(atPeriod(T.Trip, P.Period))) AS Distance
FROM Trips T, Periods P
WHERE T.Trip &amp;&amp; P.Period
GROUP BY T.VehId, P.PeriodId, P.Period
ORDER BY T.VehId, P.PeriodId;
</programlisting>
					<para>The query performs a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on the <varname>Trips</varname> table. It then projects the trip to the period, computes the length of the projected trip, and sum the lengths of all the trips of the same vehicle during the period.</para>
				</listitem>

				<listitem id="qa_distance_static">
					<para>List the minimum distance ever between each vehicle and each point from <varname>Points</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T.VehId, P.PointId, MIN(trajectory(T.Trip) &lt;-&gt; P.Geom) AS MinDistance
FROM Trips T, Points P
GROUP BY T.VehId, P.PointId
ORDER BY T.VehId, P.PointId;
</programlisting>
					<para>The query projects the trip to the spatial dimension with the <varname>trajectory</varname> function and computes the traditional distance between the trajectory of the trip and the point. The traditional minimum function is then applied for computing the minimum distance between all trips of the vehicle and the point.</para>
				</listitem>

				<listitem id="qa_distance_moving">
					<para>List the minimum temporal distance between each pair of vehicles.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T1.VehId AS Car1Id, T2.VehId AS Car2Id, tmin(T1.Trip &lt;-&gt; T2.Trip) AS MinDistance
FROM Trips T1, Trips T2
WHERE T1.VehId &lt; T2.VehId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
GROUP BY T1.VehId, T2.VehId
ORDER BY T1.VehId, T2.VehId;
</programlisting>
					<para>The query selects two trips <varname>T1</varname> and <varname>T2</varname> from different vehicles that were both traveling during a common period of time, computes the temporal distance between the trips, and then computes the temporal minimum distance between all trips of the two vehicles. The query uses the spatio-temporal index to filter the pairs of trips that were both traveling during a common period of time.</para>
				</listitem>

				<listitem id="qa_nearest_approach">
					<para>List the nearest approach time, distance, and shortest line between each pair of trips.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T1.VehId AS Car1Id, T1.TripId AS Trip1Id, T2.VehId AS Car2Id, 
  T2.TripId AS Trip2Id, period(NearestApproachInstant(T1.Trip, T2.Trip)) AS Time,
  NearestApproachDistance(T1.Trip, T2.Trip) AS Distance, 
  ShortestLine(T1.Trip, T2.Trip) AS Line
FROM Trips T1, Trips T2
WHERE T1.VehId &lt; T2.VehId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
ORDER BY T1.VehId, T1.TripId, T2.VehId, T2.TripId;
</programlisting>
					<para>This query shows similar functionality as that provided by the PostGIS functions <varname>ST_ClosestPointOfApproach</varname> and <varname>ST_DistanceCPA</varname>. The query selects two trips <varname>T1</varname> and <varname>T2</varname> from different vehicles that were both traveling during a common period of time and computes the required results.</para>
				</listitem>

				<listitem id="qa_distance_tdwithin">
					<para>List when and where a pairs of vehicles have been at 10 m or less from each other.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T1.VehId AS VehId1, T2.VehId AS VehId2, atPeriodSet(T1.Trip,
  getTime(tdwithin(T1.Trip, T2.Trip, 10.0, TRUE))) AS Position
FROM Trips T1, Trips T2
WHERE T1.VehId &lt; T2.VehId AND T1.Trip &amp;&amp; expandSpatial(T2.Trip, 10) AND
  tdwithin(T1.Trip, T2.Trip, 10.0, TRUE) IS NOT NULL
ORDER BY T1.VehId, T2.VehId, Position;
</programlisting>
					<para>The query performs for each pair of trips <varname>T1</varname> and <varname>T2</varname> of different vehicles a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on the <varname>Trips</varname> table, where the bounding box of <varname>T2</varname> is expanded by 10 m. Then, the <varname>period</varname> expression computes the periods during which the vehicles were within 10 m. from each other and the <varname>atPeriodSet</varname> function projects the trips to those periods. Notice that the expression <varname>tdwithin(T1.Trip, T2.Trip, 10.0)</varname> is conceptually equivalent to <varname>dwithin(T1.Trip, T2.Trip) #&lt;= 10.0</varname>. However, in this case the spatio-temporal index cannot be used for filtering values.</para>
				</listitem>
			</orderedlist>
		</sect2>

		<sect2>
			<title>Nearest-Neighbor Queries</title>
			<para>There are three common types of nearest-neighbor queries in spatial databases.
				<itemizedlist>
					<listitem>
						<para>k-nearest-neighbor (kNN) queries find the k nearest points to a given point.</para>
					</listitem>

					<listitem>
						<para>Reverse k-nearest-neighbor (RkNN) queries find the points that have a given point among their k nearest-neighbors.</para>
					</listitem>

					<listitem>
						<para>Given two sets of points P and Q, aggregate nearest-neighbor (ANN) queries find the points from P that have minimum aggregated distance to all points from Q.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>The above types of queries are generalized to temporal points. However, the complexity of these queries depend on whether the reference object and the candidate objects are static or moving. In the examples that follow we only consider the nontemporal version of the nearest-neighbor queries, that is, the one in which the calculation is performed on the projection of temporal points on the spatial dimension. The temporal version of the nearest-neighbor queries remains to be done.</para>

			<orderedlist continuation="continues">
				<listitem id="qa_knn_static">
					<para>For each trip from <varname>Trips</varname>, list the three points from <varname>Points</varname> that have been closest to that vehicle.</para>
					<programlisting language="sql" xml:space="preserve">
WITH TripsTraj AS (
  SELECT TripId, VehId, trajectory(Trip) AS Trajectory FROM Trips )
SELECT T.VehId, P1.PointId, P1.Distance
FROM TripsTraj T CROSS JOIN LATERAL (
  SELECT P.PointId, T.Trajectory &lt;-&gt; P.Geom AS Distance
  FROM Points P
  ORDER BY Distance LIMIT 3 ) AS P1
ORDER BY T.TripId, T.VehId, P1.Distance;
</programlisting>
					<para>This is a nearest-neighbor query with moving reference objects and static candidate objects. The query above uses PostgreSQL's lateral join, which intuitively iterates over each row in a result set and evaluates a subquery using that row as a parameter. The query starts by computing the trajectory of the trips in the temporary table <varname>TripsTraj</varname>. Then, given a trip <varname>T</varname> in the outer query, the subquery computes the traditional distance between the trajectory of <varname>T</varname> and each point <varname>P</varname>. The <varname>ORDER BY</varname> and <varname>LIMIT</varname> clauses in the inner query select the three closest points. PostGIS will use the spatial index on the <varname>Points</varname> table for selecting the three closest points.</para>
				</listitem>

				<listitem id="qa_knn_moving">
					<para>For each trip from <varname>Trips</varname>, list the three vehicles that are closest to that vehicle</para>
					<programlisting language="sql" xml:space="preserve">
SELECT T1.VehId AS VehId1, C2.VehId AS VehId2, C2.Distance
FROM Trips T1 CROSS JOIN LATERAL (
  SELECT T2.VehId, minValue(T1.Trip &lt;-&gt; T2.Trip) AS Distance
  FROM Trips T2
  WHERE T1.VehId &lt; T2.VehId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
  ORDER BY Distance LIMIT 3 ) AS C2
ORDER BY T1.VehId, C2.VehId;
</programlisting>
					<para>This is a nearest-neighbor query where both the reference and the candidate objects are moving. Therefore, it is not possible to proceed as in the previous query to first project the moving points to the spatial dimension and then compute the traditional distance. Given a trip <varname>T1</varname> in the outer query, the subquery computes the temporal distance between <varname>T1</varname> and a trip <varname>T2</varname> of another vehicle different from the vehicle from <varname>T1</varname> and then computes the minimum value in the temporal distance. Finally, the <varname>ORDER BY</varname> and <varname>LIMIT</varname> clauses in the inner query select the three closest vehicles.</para>
				</listitem>

				<listitem id="qa_rknn_static">
					<para>For each trip from <varname>Trips</varname>, list the points from <varname>Points</varname> that have that vehicle among their three nearest neighbors.</para>
					<programlisting language="sql" xml:space="preserve">
WITH TripsTraj AS (
  SELECT TripId, VehId, trajectory(Trip) AS Trajectory FROM Trips ),
PointTrips AS (
  SELECT P.PointId, T2.VehId, T2.TripId, T2.Distance
  FROM Points P CROSS JOIN LATERAL (
    SELECT T1.VehId, T1.TripId, P.Geom &lt;-&gt; T1.Trajectory AS Distance
    FROM TripsTraj T1
    ORDER BY Distance LIMIT 3 ) AS T2 )
SELECT T.VehId, T.TripId, P.PointId, PT.Distance
FROM Trips T CROSS JOIN Points P JOIN PointTrips PT
  ON T.VehId = PT.VehId AND T.TripId = PT.TripId AND P.PointId = PT.PointId
ORDER BY T.VehId, T.TripId, P.PointId;
</programlisting>
					<para>This is a reverse nearest-neighbor query with moving reference objects and static candidate objects. The query starts by computing the corresponding nearest-neighbor query in the temporary table <varname>PointTrips</varname> as it is done in Query 13. Then, in the main query it verifies for each trip <varname>T</varname> and point <varname>P</varname> that both belong to the <varname>PointTrips</varname> table.</para>
				</listitem>

				<listitem id="qa_rknn_moving">
					<para>For each trip from <varname>Trips</varname>, list the vehicles having the vehicle of the trip among the three nearest neighbors.</para>
					<programlisting language="sql" xml:space="preserve">
WITH TripDistances AS (
  SELECT T1.VehId AS VehId1, T1.TripId AS TripId1, T3.VehId AS VehId2, 
    T3.TripId AS TripId2, T3.Distance
  FROM Trips T1 CROSS JOIN LATERAL (
    SELECT T2.VehId, T2.TripId, minValue(T1.Trip &lt;-&gt; T2.Trip) AS Distance
    FROM Trips T2
    WHERE T1.VehId &lt; T2.VehId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
    ORDER BY Distance LIMIT 3 ) AS T3 )
SELECT T1.VehId, T1.TripId, T2.VehId, T2.TripId, TD.Distance
FROM Trips T1 JOIN Trips T2 ON T1.VehId &lt; T2.VehId
  JOIN TripDistances TD ON T1.VehId = TD.VehId1 AND T1.TripId = TD.TripId1 AND
  T2.VehId = TD.VehId2 AND T2.TripId = TD.TripId2
ORDER BY T1.VehId, T1.TripId, T2.VehId, T2.TripId;
</programlisting>
					<para>This is a reverse nearest-neighbor query where both the reference and the candidate objects are moving. The query starts by computing the corresponding nearest-neighbor query in the temporary table <varname>TripDistances</varname> as it is done in Query 14. Then, in the main query it verifies for each pair of trips <varname>T1</varname> and <varname>T2</varname> that both belong to the <varname>TripDistances</varname> table.</para>
				</listitem>

				<listitem id="qa_ann">
					<para>For each group of ten disjoint vehicles, list the point(s) from <varname>Points</varname>, having the minimum aggregated distance from the given group of ten vehicles during the given period.</para>
					<programlisting language="sql" xml:space="preserve">
WITH Groups AS (
  SELECT ((ROW_NUMBER() OVER (ORDER BY V.VehId))-1)/10 + 1 AS GroupId, V.VehId
  FROM Vehicles V ),
SumDistances AS (
  SELECT G.GroupId, P.PointId,
    SUM(ST_Distance(trajectory(T.Trip), P.Geom)) AS SumDist
  FROM Groups G, Points P, Trips T
  WHERE T.VehId = G.VehId
  GROUP BY G.GroupId, P.PointId )
SELECT S1.GroupId, S1.PointId, S1.SumDist
FROM SumDistances S1
WHERE S1.SumDist &lt;= ALL (
  SELECT SumDist
  FROM SumDistances S2
  WHERE S1.GroupId = S2.GroupId )
ORDER BY S1.GroupId, S1.PointId;
</programlisting>
					<para>This is an aggregate nearest-neighbor query. The temporary table <varname>Groups</varname> splits the vehicles in groups where the <varname>GroupId</varname> column takes the values from 1 to total number of groups. The temporary table <varname>SumDistances</varname> computes for each group <varname>G</varname> and point <varname>P</varname> the sum of the distances between a trip of a vehicle in the group and the point. The main query then selects for each group in table <varname>SumDistances</varname> the points(s) that have the minimum aggregated distance.</para>
				</listitem>
			</orderedlist>
		</sect2>
	</sect1>
</chapter>
